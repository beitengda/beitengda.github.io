---
title: spring自定义注解使用
date: 2019-08-12
comments: true
categories:
- java
- springboot
tags:
- java
- springboot
---

## 注解的定义

### @Target

**代表注解作用的位置(注解生效位置可设置多个)**

| 可用值       | 作用位置 
| :--------------- | :--: | 
| ElemenetType.FIELD    |  类成员  |  
| ElemenetType.METHOD   |  方法  |   
| ElemenetType.TYPE |  类/接口/枚举  | 
| ElemenetType.CONSTRUCTOR |构造器声明|

<!-- more -->

### @Retention

**代表注解生效的阶段(生命周期)**

**RetentionPolicy.SOURCE**：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃  
**RetentionPolicy.CLASS**：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；  
**RetentionPolicy.RUNTIME**：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；


```java
@Target(value={ElementType.TYPE,ElementType.FIELD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface MyAnnotation {

    String value() default "hello";
}
```
## 作用于方法的注解

1. 定义注解
2. 定义Aspect切面类，设置切点(@PointCut)和拦截逻辑
3. 将切面类注入到Spring上下文

```java
@Component
@Aspect
public class MyAspect {

    @Pointcut("@annotation(com.qianshan.demo.annotation.MyAnnotation)")
    public void pointCut() {

    }

    @Around("pointCut()&&@annotation(myAnnotation)")
    public Object handle(ProceedingJoinPoint joinPoint, MyAnnotation myAnnotation) throws Throwable {
        System.out.println("注解作用的方法名: " + joinPoint.getSignature().getName());
        System.out.println("所在类的简单类名: " + joinPoint.getSignature().getDeclaringType().getSimpleName());
        System.out.println("所在类的完整类名: " + joinPoint.getSignature().getDeclaringType());
        System.out.println("目标方法的声明类型: " + Modifier.toString(joinPoint.getSignature().getModifiers()));
        //获取注解值
        String value = myAnnotation.value();
        //获取方法参数
        Object args[] = joinPoint.getArgs();
        return joinPoint.proceed();
    }
}
```

![](https://oscimg.oschina.net/oscnet/be1412c6890280b7976893810e491212df3.jpg)